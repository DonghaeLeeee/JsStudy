<!DOCTYPE html>
<html lang="kr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>

    <script>

        var d = 'X';

        function outer() {
            var a = 1;
            var b = 'B';
            console.log(a);

            function inner() {
                var a = 2;
                console.log(a);
                console.log(b);
                console.log(d);
            }
            return inner
        }

        var someFun = outer();
        someFun();






        // a에 무슨값이 있는지 찾는곳이 스코프
        // 변수나 함수명을 가지고 거기 들어있는 값을 찾을때 들여다보는곳이 '스코프'
        // 스코프는 함수에 속해있다.
        // 자바스크립트는 함수 단위로 스코프가 생성된다.
        // inner함수가 실행될때 표를 찾는것이 스코프
        // outer함수에서 만든 변수b를 inner함수에서 사용해도 그대로찍힌다.
        // inner함수의 스코프에서 찾아본뒤, 없으면 outer함수의 스코프를 찾아본다.
        // 둘이 연결되어있기때문
        // inner함수가 생성된곳이 outer함수 범위 안에있기때문에 inner 다음은 outer 이다.
        // 사실 outer함수 스코프 안에는 inner함수도 들어가있다.
        // 글로벌 스코프도 있다.
        // 변수 d의 위치가 위쪽이든 아래쪽이든 상관없음
        // 스코프 끼리 연결되어있는것이 '스코프체인' 이다.
        // '클로저' 란 생성한 시점에 스코프체인을 계속 들고있는다
        // 들고있기때문에 그게 일종의 클로저 이고
        // 클로저 때문에 outer가 실행된 다음에도 somefun에서도 b가찍히는것  
        // outer내부에서 선언한 변수는 outer가 실행하는 순간 return 하고 끝나면 변수가 사라진다고생각한다
        // 근데 여기선 b가 찍혀여 이게 바로 클로저

        // 다른 언어는 리턴하고 끝나면 함수 내부 변수는 사라지지만 
        // 자바 스크립트는 클로저로 인해 사라지지 않고 참조됨

        // 다른 코드가 참조할수있는 어떠한 범위가 결정된것
        // 이러한 유효범위를 스코프라고한다.
        // 변수이름, 함수이름, 클래스이름 과 같은 식별자가
        // 본인이 선언된 위치에 따라 다른 코드에서 자신이 참조될수 있을지 없을지 결정되는 것 => 스코프

        // 함수 내부 몸체에서 정의되는것을 함수의 중첩이라고한다.
        // 함수 내부에서 정의된 함수 = 중첩 함수, 중첩함수를 포함하는 함수 = 외부함수
        // 함수가 중첩이된다면, 각각 함수의 지역 스코프도 중첩이 된다.
        // 이는 스코프가 함수의 중첩에 의해 계층적인 구조를 가질 수 있다는 것을 의미한다.
        // 스코프가 계층적으로 연결되어있는것을 '스코프체인' 이라고한다.
        // 스코프체인은 물리적으로 존재한다.
        // 변수를 참조할때 자바스크립트 엔진은 스코프체인을 통해 변수를 참조한다.
        // 현재 함수가 어떤 변수를 참조하려고하는데, 내 스코프안에 원하는 변수가 없다 -> 하나위로 올라간다
        // 그렇게 전역까지 갔는데 없으면 그때는 referenceError를 출력한다.
        // 스코프 체인에서 변수를 참조할때는 무조건 위로만 올라간다. -> 스코프체인의 반방향성

        // 스코프는 어떤 레벨을 가지느냐에 따라 '블록 레벨 스코프' 와 '함수 레벨 스코프' 로 구분한다.
        // 블록 레벨 스코프 : if문, for문, 함수...
        // 함수 레벨 스코프 : only 함수
        // 자바스크립트에서는 var키워드로 선언된 변수는 오로지 함수 코드 블록만을 지역 스코프로 인정한다. -> 함수레벨스코프
        // 자바스크립트에서 블록레벨스코프를 갖으려고 만든것이 let,const키워드 이다.

        // 스코프는 상위 스코프가 결정되는 시점을 기준으로 '동적 스코프' 와 '정적 스코프'로 나뉜다.
        // 함수가 어디서 호출이 되었는지에 따라 그리고 함수가 어디서 정의되었는지에 따라서 나뉠수있다.
        // 함수가 어디서 호출 되는지에 따라 동적으로 상위 스코프가 결정되는것을 동적스코프라고한다.
        // 프로그램 런타임 도중에 실행 컨텍스트 나 호출 컨텍스트에 의해서 스코프가 결정되는것을 의미한다.
        // 함수가 정의되는 시점에 딱 상위 스코프가 결정되는것을 정적스코프라고 한다.(=== 렉시컬 스코프)
        // 자바스크립트는 렉시컬스코프를 따르기 때문에 함수는 만들어지자마자 상위스코프가 결정된다.
        // 이후에 해당 함수에 의해 함수 객체가 생성이되면 해당 함수 객체는 본인의 상위 스코프를 항상 알수있다.
        // 해당함수가 상위 스코프를 항상 알 수 있게 되는 이유는
        // 자바스크립트에서 함수는 만들어지면서 자신의 내부 슬롯에 상위스코프의 참조를 저장하기때문이다.

        // 함수 실행 -> 실행 컨텍스트 생성 -> 이를 실행 컨텍스트 스택에 push 
        // -> 그 후에 함수는 본인의 렉시컬 환경을 생성 -> 코드의 실행이 끝나면 실행 컨텍스트 스택에서 해당 컨텍스트를 pop하여 제거

        // 렉시컬 환경 : 어떠한 코드가 어디서 실행이 되고 본인 주변에 어떤 코드들이 있는지 대체적인 정보를 담고있는 환경
        // 렉시컬 환경은 함수 본인 내부의 식별자, 식별자에 바인딘 된 값등을 기록하고있는 하나의 자료구조

        // 클로저 : 중첩함수가 생명주기를 다한 외부함수 즉, 내부함수의 지역변수 를 참조할수있다면
        // 이때 중첩함수를 클로저 라고한다.
        // 클로저 : 한 중첩 함수가 상위 스코프의 식별자를 참조하고있고 거기서 중첩함수의 외부 함수보다
        // 더 오래 살아있다면 유지가 된다면 이 중첩함수는 클로저이다.
        // 이러한 클로저는 본인의 상위 스코프에서 현재 참조하는 식별자만을 기억하는데
        // 이렇게 클로저에 의해 참조된 변수를 자유변수라고 한다.
        // 이러한 클로저는 하나의 state가 의도치 않게 변경되지 않도록
        // state를 안전하게 은닉하고 또는 특정 함수에게만 state변경을 허용하기 위해 사용한다고한다.


        
    </script>
</body>

</html>